"""
MongoDB implementation of the database interface.
Each manager is implemented as a separate class for clean separation.
"""

import logging
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple
from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase
from bson import ObjectId
from pymongo.errors import DuplicateKeyError

from .base import DatabaseInterface
from .core_manager import CoreManager
from .document_manager import DocumentManager
from .entity_manager import EntityManager
from .index_manager import IndexManager
from app.services.notify import Notification, Warning, Error, DuplicateConstraintError
from app.services.metadata import MetadataService


class MongoCore(CoreManager):
    """MongoDB implementation of core operations"""
    
    def __init__(self, parent: 'MongoDatabase'):
        self.parent = parent
        self._client: Optional[AsyncIOMotorClient] = None
        self._db: Optional[AsyncIOMotorDatabase] = None
    
    @property
    def id_field(self) -> str:
        return "_id"
    
    async def init(self, connection_str: str, database_name: str) -> None:
        """Initialize MongoDB connection"""
        if self._client is not None:
            logging.info("MongoDatabase: Already initialized")
            return

        self._client = AsyncIOMotorClient(connection_str)
        self._db = self._client[database_name]
        
        # Test connection
        await self._client.admin.command('ping')
        self.parent._initialized = True
        logging.info(f"MongoDatabase: Connected to {database_name}")
    
    async def close(self) -> None:
        """Close MongoDB connection"""
        if self._client:
            self._client.close()
            self._client = None
            self._db = None
            self.parent._initialized = False
            logging.info("MongoDatabase: Connection closed")
    
    def get_id(self, document: Dict[str, Any]) -> Optional[str]:
        """Extract and normalize ID from MongoDB document"""
        if not document:
            return None
            
        id_value = document.get(self.id_field)
        if id_value is None:
            return None
            
        # Convert ObjectId to string
        if isinstance(id_value, ObjectId):
            return str(id_value)
        
        return str(id_value) if id_value else None
    
    def get_connection(self) -> AsyncIOMotorDatabase:
        """Get MongoDB database instance"""
        if self._db is None:
            raise RuntimeError("MongoDB not initialized")
        return self._db


class MongoDocuments(DocumentManager):
    """MongoDB implementation of document operations"""
    
    def __init__(self, parent: 'MongoDatabase'):
        self.parent = parent
    
    async def get_all(
        self, 
        entity_type: str,
        sort: Optional[List[Tuple[str, str]]] = None,
        filter: Optional[Dict[str, Any]] = None,
        page: int = 1,
        pageSize: int = 25
    ) -> Tuple[List[Dict[str, Any]], int]:
        """Get paginated list of documents"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        collection = entity_type
        
        # Build query filter
        query = self._build_query_filter(filter, entity_type) if filter else {}
        
        # Get total count
        total_count = await db[collection].count_documents(query)
        
        # Build sort specification
        sort_spec = self._build_sort_spec(sort, entity_type)
        
        # Execute paginated query
        skip_count = (page - 1) * pageSize
        cursor = db[collection].find(query).sort(sort_spec).skip(skip_count).limit(pageSize)
        
        # Apply case-insensitive collation if configured
        if not self.parent.case_sensitive_sorting:
            cursor = cursor.collation({"locale": "en", "strength": 2})
        
        raw_documents = await cursor.to_list(length=pageSize)
        
        # Normalize documents
        documents = [self._normalize_document(doc) for doc in raw_documents]
        
        return documents, total_count
    
    async def get(self, id: str, entity_type: str) -> Tuple[Dict[str, Any], int]:
        """Get single document by ID"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        try:
            collection = entity_type
            
            # Convert string ID to ObjectId for MongoDB
            object_id = ObjectId(id) if ObjectId.is_valid(id) else id
            
            doc = await db[collection].find_one({"_id": object_id})
            
            if doc:
                normalized_doc = self._normalize_document(doc)
                return normalized_doc, 1
            else:
                Notification.warning(Warning.NOT_FOUND, "Document not found", entity_type=entity_type, entity_id=id)
                return {}, 0
            
        except Exception as e:
            Notification.error(Error.DATABASE, f"MongoDB get error: {str(e)}")

        return {}, 0

    async def delete(self, id: str, entity_type: str) -> Tuple[Dict[str, Any], int]:
        """Delete document by ID"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        try:
            collection = entity_type
            
            # Convert string ID to ObjectId for MongoDB
            object_id = ObjectId(id) if ObjectId.is_valid(id) else id
            
            # Use findOneAndDelete for atomic operation that returns deleted document
            deleted_doc = await db[collection].find_one_and_delete({"_id": object_id})
            
            if deleted_doc:
                normalized_doc = self._normalize_document(deleted_doc)
                return normalized_doc, 1
            else:
                Notification.warning(Warning.NOT_FOUND, "Document not found for deletion", entity_type=entity_type, entity_id=id)
                return {}, 0
            
        except Exception as e:
            Notification.error(Error.DATABASE, f"MongoDB delete error: {str(e)}")

        return {}, 0
    
    async def _validate_document_exists_for_update(self, entity_type: str, id: str) -> bool:
        """Validate that document exists for update operations"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        try:
            collection = entity_type
            mongo_id = ObjectId(id) if ObjectId.is_valid(id) else id
            existing_doc = await db[collection].find_one({"_id": mongo_id})
            
            if not existing_doc:
                Notification.warning(Warning.NOT_FOUND, "Document not found for update", entity_type=entity_type, entity_id=id)
                return False
            
            return True
        except Exception:
            Notification.warning(Warning.NOT_FOUND, "Document not found for update", entity_type=entity_type, entity_id=id)
            return False
    
    async def _create_document(self, entity_type: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Create document in MongoDB"""
        db = self.parent.core.get_connection()
        
        try:
            collection = entity_type
            create_data = data.copy()
            
            # If data contains 'id', use it as MongoDB _id
            if 'id' in create_data:
                create_data["_id"] = create_data.pop('id')
            
            result = await db[collection].insert_one(create_data)
            saved_doc = create_data.copy()
            if "_id" not in saved_doc:
                saved_doc["_id"] = result.inserted_id
            return saved_doc
            
        except DuplicateKeyError as e:
            field, value = self._parse_duplicate_key_error(e)
            error = DuplicateConstraintError(
                message=f"Duplicate value for field '{field}'",
                entity=entity_type,
                field=field,
                entity_id=data.get('id', 'new')
            )
            Notification.handle_duplicate_constraint(error)

        return {}

    async def _update_document(self, entity_type: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Update existing document in MongoDB"""
        db = self.parent.core.get_connection()
        
        try:
            collection = entity_type
            id = data['id']
            mongo_id = ObjectId(id) if ObjectId.is_valid(id) else id
            
            # Create update data without 'id' field
            update_data = data.copy()
            del update_data['id']
            update_data["_id"] = mongo_id
            
            await db[collection].replace_one({"_id": mongo_id}, update_data, upsert=False)
            return update_data
                
        except DuplicateKeyError as e:
            field, value = self._parse_duplicate_key_error(e)
            error = DuplicateConstraintError(
                message=f"Duplicate value for field '{field}'",
                entity=entity_type,
                field=field,
                entity_id=data.get('id', 'new')
            )
            Notification.handle_duplicate_constraint(error)
    
        return {}

    def _get_core_manager(self) -> CoreManager:
        """Get the core manager instance"""
        return self.parent.core
    
    def _prepare_datetime_fields(self, entity_type: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Convert datetime fields for MongoDB storage"""
        fields_meta = MetadataService.fields(entity_type)
        prepared_data = data.copy()
        
        for field_name, value in prepared_data.items():
            if value is None:
                continue
                
            field_meta = fields_meta.get(field_name, {})
            field_type = field_meta.get('type')
            
            if field_type in ['Date', 'Datetime'] and isinstance(value, str):
                try:
                    date_str = value.strip()
                    if date_str.endswith('Z'):
                        date_str = date_str[:-1] + '+00:00'
                    prepared_data[field_name] = datetime.fromisoformat(date_str)
                except (ValueError, TypeError):
                    pass
        
        return prepared_data
    
    def _convert_filter_values(self, filters: Dict[str, Any], entity_type: str) -> Dict[str, Any]:
        """Convert filter values to MongoDB-appropriate types"""
        if not filters:
            return filters
            
        converted_filters = {}
        fields_meta = MetadataService.fields(entity_type)
        
        for field_name, filter_value in filters.items():
            field_meta = fields_meta.get(field_name, {})
            field_type = field_meta.get('type', 'String')
            
            if isinstance(filter_value, dict):
                # Range queries like {"$gte": 21, "$lt": 65}
                converted_range = {}
                for op, value in filter_value.items():
                    converted_range[op] = self._convert_single_value(value, field_type)
                converted_filters[field_name] = converted_range
            else:
                # Simple equality filter
                converted_filters[field_name] = self._convert_single_value(filter_value, field_type)
        
        return converted_filters
    
    def _convert_single_value(self, value: Any, field_type: str) -> Any:
        """Convert a single value to appropriate type for MongoDB"""
        if value is None:
            return value
            
        if field_type in ['Date', 'Datetime'] and isinstance(value, str):
            try:
                date_str = value.strip()
                if date_str.endswith('Z'):
                    date_str = date_str[:-1] + '+00:00'
                return datetime.fromisoformat(date_str)
            except (ValueError, TypeError):
                return value
        
        return value
    
    async def _validate_unique_constraints(
        self, 
        entity_type: str, 
        data: Dict[str, Any], 
        unique_constraints: List[List[str]], 
        exclude_id: Optional[str] = None
    ) -> bool:
        """Validate unique constraints for MongoDB"""
        return True  # MongoDB handles unique constraints natively
    
    def _build_query_filter(self, filters: Dict[str, Any], entity_type: str) -> Dict[str, Any]:
        """Build MongoDB query from filter conditions"""
        if not filters:
            return {}
        
        converted_filters = self._convert_filter_values(filters, entity_type)
        fields_meta = MetadataService.fields(entity_type)
        query: Dict[str, Any] = {}
        
        for field, value in converted_filters.items():
            if isinstance(value, dict) and any(op in value for op in ['$gte', '$lte', '$gt', '$lt']):
                # Range query
                field_type = fields_meta.get(field, {}).get('type', 'String')
                if field_type in ['Date', 'Datetime', 'Integer', 'Currency', 'Float']:
                    enhanced_filter = value.copy()
                    enhanced_filter['$exists'] = True
                    enhanced_filter['$ne'] = None
                    query[field] = enhanced_filter
                else:
                    query[field] = value
            else:
                # Determine matching strategy
                field_meta = fields_meta.get(field, {})
                field_type = field_meta.get('type', 'String')
                has_enum_values = 'enum' in field_meta
                
                if field_type == 'String' and not has_enum_values:
                    # Free text fields: partial match with regex
                    query[field] = {"$regex": f".*{self._escape_regex(str(value))}.*", "$options": "i"}
                else:
                    # Enum fields and non-text fields: exact match
                    if isinstance(value, str) and ObjectId.is_valid(value):
                        query[field] = ObjectId(value)
                    else:
                        query[field] = value
        
        return query
    
    def _build_sort_spec(self, sort_fields: Optional[List[Tuple[str, str]]], entity_type: str) -> List[Tuple[str, int]]:
        """Build MongoDB sort specification"""
        if sort_fields:
            return [(field, 1 if direction == "asc" else -1) for field, direction in sort_fields]
        else:
            return [("_id", 1)]  # Default sort by _id ascending
    
    def _parse_duplicate_key_error(self, error: DuplicateKeyError) -> Tuple[str, str]:
        """Parse MongoDB duplicate key error to extract field and value"""
        error_msg = str(error)
        if "index:" in error_msg:
            parts = error_msg.split("index:")
            if len(parts) > 1:
                index_info = parts[1].strip()
                field_name = index_info.split("_")[0]
                return field_name, "unknown_value"
        return "unknown_field", "unknown_value"
    
    def _escape_regex(self, text: str) -> str:
        """Escape special regex characters"""
        import re
        return re.escape(text)


class MongoEntities(EntityManager):
    """MongoDB implementation of entity operations"""
    
    def __init__(self, parent: 'MongoDatabase'):
        self.parent = parent
    
    async def exists(self, entity_type: str) -> bool:
        """Check if collection exists"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        collection_names = await db.list_collection_names()
        return entity_type in collection_names
    
    async def create(self, entity_type: str, unique_constraints: List[List[str]]) -> bool:
        """Create collection with unique indexes"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        try:
            for constraint_fields in unique_constraints:
                index_spec = [(field, 1) for field in constraint_fields]
                await db[entity_type].create_index(index_spec, unique=True)
            return True
        except Exception as e:
            Notification.error(Error.DATABASE, f"MongoDB create entity error: {str(e)}")
        return False

    async def delete(self, entity_type: str) -> bool:
        """Drop collection"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        try:
            await db[entity_type].drop()
            return True
        except Exception as e:
            Notification.error(Error.DATABASE, f"MongoDB delete entity error: {str(e)}")
        return False
    
    async def get_all(self) -> List[str]:
        """Get all collection names"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        return await db.list_collection_names()


class MongoIndexes(IndexManager):
    """MongoDB implementation of index operations"""
    
    def __init__(self, parent: 'MongoDatabase'):
        self.parent = parent
    
    async def create(
        self, 
        entity_type: str, 
        fields: List[str],
        unique: bool = False,
        name: Optional[str] = None
    ) -> None:
        """Create index on collection"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        try:
            index_spec = [(field, 1) for field in fields]
            kwargs: Dict[str, Any] = {"unique": unique}
            if name:
                kwargs["name"] = name
                
            await db[entity_type].create_index(index_spec, **kwargs)
        except Exception as e:
            Notification.error(Error.DATABASE, f"MongoDB create index error: {str(e)}")
    
    async def get_all(self, entity_type: str) -> List[List[str]]:
        """Get all unique indexes for collection as field lists"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        try:
            field_lists = []
            cursor = db[entity_type].list_indexes()
            
            async for index_info in cursor:
                if index_info.get("name") == "_id_":
                    continue
                    
                if not index_info.get("unique", False):
                    continue
                
                fields = []
                for field_spec in index_info.get("key", {}).items():
                    fields.append(field_spec[0])
                
                if fields:
                    field_lists.append(fields)
            
            return field_lists
        except Exception as e:
            Notification.error(Error.DATABASE, f"MongoDB get indexes error: {str(e)}")
        return []
    
    async def delete(self, entity_type: str, fields: List[str]) -> None:
        """Delete index by field names"""
        self.parent._ensure_initialized()
        db = self.parent.core.get_connection()
        
        try:
            index_spec = [(field, 1) for field in fields]
            await db[entity_type].drop_index(index_spec)
        except Exception as e:
            Notification.error(Error.DATABASE, f"MongoDB delete index error: {str(e)}")


class MongoDatabase(DatabaseInterface):
    """MongoDB implementation of DatabaseInterface"""
    
    def _get_manager_classes(self) -> dict:
        """Return MongoDB manager classes"""
        return {
            'core': MongoCore,
            'documents': MongoDocuments,
            'entities': MongoEntities,
            'indexes': MongoIndexes
        }
    
    async def supports_native_indexes(self) -> bool:
        """MongoDB supports native unique indexes"""
        return True