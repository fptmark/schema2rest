{% if inheritsBaseEntity %}
from .BaseEntity import BaseEntity
from beanie import PydanticObjectId
{% else %}
from beanie import Document
{% endif %}
from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime
import re
import json

{% if uniques %}
class UniqueValidationError(Exception):
    def __init__(self, fields, query):
        self.fields = fields
        self.query = query
        super().__init__(f"Unique constraint violated for fields: {', '.join(fields)}")
{% endif %}

{% if inheritsBaseEntity %}
class {{ entity|capitalize }}(BaseEntity):
{% else %}
class {{ entity|capitalize }}(Document):
{% endif %}
{% for field_name, field_info in fields.items() %}
    {{ field_name }}: {{ field_info|model_field }}
{% endfor %}

    class Settings:
        name = "{{ entity|lower() }}"

    {# Custom validators for fields with custom messages #}
    {% for field_name, field_info in fields.items() %}
        {# Initialize a messages dictionary from keys ending with ".message" #}
        {% set ns = namespace(messages = {}) %}
        {% for key, value in field_info.items() %}
            {% if key.endswith('.message') %}
                {% set base_key = key[:-8] %}
                {% set ns.messages = ns.messages | combine({base_key: value}) %}
            {% endif %}
        {% endfor %}
        {% if ns.messages %}
    @validator('{{ field_name }}')
    def validate_{{ field_name }}(cls, v):
        {# If a custom minLength message is provided, validate the length #}
        {% if ns.messages.get('minLength') is not none and field_info.get('minLength') is not none %}
        if len(v) < {{ field_info.get('minLength') }}:
            raise ValueError("{{ ns.messages.get('minLength') }}")
        {% endif %}
        {# If a custom maxLength message is provided #}
        {% if ns.messages.get('maxLength') is not none and field_info.get('maxLength') is not none %}
        if len(v) > {{ field_info.get('maxLength') }}:
            raise ValueError("{{ ns.messages.get('maxLength') }}")
        {% endif %}
        {# If a custom pattern message is provided #}
        {% if ns.messages.get('pattern') is not none and field_info.get('pattern') is not none %}
        if not re.match(r'{{ field_info.get("pattern") }}', v):
            raise ValueError("{{ ns.messages.get('pattern') }}")
        {% endif %}
        return v
    {% endif %}
    {% endfor %}

{% if uniques %}
    async def validate_uniques(self):
    {% for unique in uniques %}
        # Unique constraint on fields: {{ unique.fields|join(', ') }}
        query = {
        {% for field in unique.fields %}
            "{{ field }}": self.{{ field }},
        {% endfor %}
        }
        existing = await self.__class__.find_one(query)
        if existing:
            raise UniqueValidationError({{ unique.fields|tojson }}, query)
    {% endfor %}

    async def save(self, *args, **kwargs):
        await self.validate_uniques()
        return await super().save(*args, **kwargs)
{% else %}
    async def save(self, *args, **kwargs):
        return await super().save(*args, **kwargs)
{% endif %}

class {{ entity|capitalize }}Create(BaseModel):
{% for field_name, field_info in fields.items() %}
    {{ field_name }}: {{ field_info|model_field }}
{% endfor %}
    class Config:
        orm_mode = True

class {{ entity|capitalize }}Read(BaseModel):
{% if inheritsBaseEntity %}
    id: Optional[PydanticObjectId] = Field(None, alias="_id")
    createdAt: Optional[datetime] = None
    updatedAt: Optional[datetime] = None
{% endif %}
{% for field_name, field_info in fields.items() %}
    {{ field_name }}: {{ field_info|model_field }}
{% endfor %}
    class Config:
        orm_mode = True
        allow_population_by_field_name = True
        json_encoders = {PydanticObjectId: str}
