{# validation.j2: field validators for ISODate, lengths, patterns, enums, and ranges #}
{% for field_name, field_info in fields.items() %}
    {% set ns = namespace(messages={}) %}
    {% for key, val in field_info.items() if key.endswith('.message') %}
    {%   set ns.messages = ns.messages | combine({ key[:-8]: val }) %}
    {% endfor %}

    {% if field_info.get('type') == 'ISODate' %}
    @validator('{{ field_name }}', pre=True)
    def parse_{{ field_name }}(cls, v):
        if v in (None, '', 'null'):
            return None
        if isinstance(v, str):
            return datetime.fromisoformat(v)
        return v

    {% endif %}

    {% set enum_info    = field_info.get('enum') %}
    {% set pattern_info = field_info.get('pattern') %}
    {% set minlen       = field_info.get('minLength') %}
    {% set maxlen       = field_info.get('maxLength') %}
    {% set minval       = field_info.get('min') %}
    {% set maxval       = field_info.get('max') %}

    {% if field_info.get('type') in ['String','str']
          or enum_info is not none
          or pattern_info is not none
          or minlen is not none
          or maxlen is not none
          or minval is not none
          or maxval is not none %}
    @validator('{{ field_name }}')
    def validate_{{ field_name }}(cls, v):
        _custom = {{ ns.messages|tojson }}

        {% if field_info.get('type') in ['String','str'] %}
            {% if minlen is not none %}
        if v is not None and len(v) < {{ minlen }}:
            raise ValueError(_custom.get('minLength',
                          '{{ field_name }} must be at least {{ minlen }} characters'))
            {% endif %}
            {% if maxlen is not none %}
        if v is not None and len(v) > {{ maxlen }}:
            raise ValueError(_custom.get('maxLength',
                          '{{ field_name }} must be at most {{ maxlen }} characters'))
            {% endif %}
        {% endif %}

        {% if pattern_info is mapping %}
            {% set regex   = pattern_info.get('regex') %}
            {% set pat_msg = pattern_info.get('message') %}
        if v is not None and not re.match(r'{{ regex }}', v):
            raise ValueError(_custom.get('pattern','{{ pat_msg }}'))
        {% elif pattern_info %}
        if v is not None and not re.match(r'{{ pattern_info }}', v):
            raise ValueError(_custom.get('pattern',
                          '{{ field_name }} is not in the correct format'))
        {% endif %}

        {% if enum_info is mapping %}
            {% set allowed   = enum_info.get('values') %}
            {% set enum_msg  = enum_info.get('message') %}
        allowed = {{ allowed|tojson }}
        if v not in allowed:
            raise ValueError(_custom.get('enum',
                          '{{ enum_msg }}' if enum_msg else
                          '{{ field_name }} must be one of ' + ','.join(allowed)))
        {% elif enum_info %}
        allowed = {{ enum_info|tojson }}
        if v not in allowed:
            raise ValueError(_custom.get('enum',
                          '{{ field_name }} must be one of ' + ','.join(allowed)))
        {% endif %}

        {% if minval is not none %}
        if v is not None and v < {{ minval }}:
            raise ValueError(_custom.get('min',
                          '{{ field_name }} must be at least {{ minval }}'))
        {% endif %}
        {% if maxval is not none %}
        if v is not None and v > {{ maxval }}:
            raise ValueError(_custom.get('max',
                          '{{ field_name }} must be at most {{ maxval }}'))
        {% endif %}

        return v
    {% endif %}
{% endfor %}
