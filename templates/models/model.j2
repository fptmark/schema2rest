{% if inheritsBaseEntity %}
from .BaseEntity import BaseEntity
from beanie import PydanticObjectId
{% else %}
from beanie import Document
{% endif %}
from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime
import re
import json

{% if uniques %}
class UniqueValidationError(Exception):
    def __init__(self, fields, query):
        self.fields = fields
        self.query = query
        super().__init__(f"Unique constraint violated for fields: {', '.join(fields)}")
{% endif %}

{% if inheritsBaseEntity %}
class {{ entity|capitalize }}(BaseEntity):
{% else %}
class {{ entity|capitalize }}(Document):
{% endif %}
{% for field_name, field_info in fields.items() %}
    {{ field_name }}: {{ field_info|model_field }}
{% endfor %}

    class Settings:
        name = "{{ entity|lower() }}"

    {# Custom validators for fields with enum constraints or custom messages #}
    {% for field_name, field_info in fields.items() %}
        {# Initialize a namespace for custom messages #}
        {% set ns = namespace(messages={}) %}
        {% for key, value in field_info.items() %}
            {% if key.endswith('.message') %}
                {% set base_key = key[:-8] %}
                {% set ns.messages = ns.messages | combine({base_key: value}) %}
            {% endif %}
        {% endfor %}
        {% if field_info.get('enum') is not none or ns.messages|length %}
    @validator('{{ field_name }}')
    def validate_{{ field_name }}(cls, v):
        _custom = {{ ns.messages|tojson }}
        {# minLength validation #}
        {% if field_info.get('minLength') is not none %}
        if len(v) < {{ field_info.get('minLength') }}:
            {% if ns.messages.get('minLength') is not none %}
            raise ValueError(_custom["minLength"])
            {% else %}
            raise ValueError("{{ field_name }} must be at least {{ field_info.get('minLength') }} characters")
            {% endif %}
        {% endif %}
        {# maxLength validation #}
        {% if field_info.get('maxLength') is not none %}
        if len(v) > {{ field_info.get('maxLength') }}:
            {% if ns.messages.get('maxLength') is not none %}
            raise ValueError(_custom["maxLength"])
            {% else %}
            raise ValueError("{{ field_name }} must be at most {{ field_info.get('maxLength') }} characters")
            {% endif %}
        {% endif %}
        {# pattern validation #}
        {% if field_info.get('pattern') is not none %}
        if not re.match(r'{{ field_info.get("pattern") }}', v):
            {% if ns.messages.get('pattern') is not none %}
            raise ValueError(_custom["pattern"])
            {% else %}
            raise ValueError("{{ field_name }} is not in the correct format")
            {% endif %}
        {% endif %}
        {# enum validation - always active if enum is defined #}
        {% if field_info.get('enum') is not none %}
        allowed = {{ field_info.get('enum')|tojson }}
        if v not in allowed:
            {% if ns.messages.get('enum') is not none %}
            raise ValueError(_custom["enum"])
            {% else %}
            raise ValueError("{{ field_name }} must be one of " + ", ".join(allowed))
            {% endif %}
        {% endif %}
        return v
        {% endif %}
    {% endfor %}

{% if uniques %}
    async def validate_uniques(self):
    {% for unique in uniques %}
        # Unique constraint on fields: {{ unique.fields|join(', ') }}
        query = {
        {% for field in unique.fields %}
            "{{ field }}": self.{{ field }},
        {% endfor %}
        }
        existing = await self.__class__.find_one(query)
        if existing:
            raise UniqueValidationError({{ unique.fields|tojson }}, query)
    {% endfor %}

    async def save(self, *args, **kwargs):
        await self.validate_uniques()
        return await super().save(*args, **kwargs)
{% else %}
    async def save(self, *args, **kwargs):
        return await super().save(*args, **kwargs)
{% endif %}

class {{ entity|capitalize }}Create(BaseModel):
{% for field_name, field_info in fields.items() %}
    {{ field_name }}: {{ field_info|model_field }}
{% endfor %}
    class Config:
        orm_mode = True

class {{ entity|capitalize }}Read(BaseModel):
{% if inheritsBaseEntity %}
    id: Optional[PydanticObjectId] = Field(None, alias="_id")
    createdAt: Optional[datetime] = None
    updatedAt: Optional[datetime] = None
{% endif %}
{% for field_name, field_info in fields.items() %}
    {{ field_name }}: {{ field_info|model_field }}
{% endfor %}
    class Config:
        orm_mode = True
        allow_population_by_field_name = True
        json_encoders = {PydanticObjectId: str}
